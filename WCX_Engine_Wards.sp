/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include "W3SIncs/War3Source_Interface"

#define MAXWARDS 64*4 //on map LOL
#define WARDBELOW -2.0 // player is 60 units tall about (6 feet)
#define WARDABOVE 160.0

new bool:WardType[MAXWARDS];
new CurrentWardCount[MAXPLAYERSCUSTOM];
new Float:WardLocation[MAXWARDS][3]; 
new WardOwner[MAXWARDS];
new WardRadius[MAXWARDS];
new WardDamage[MAXWARDS];
new Float:WardDuration[MAXWARDS];
new Handle:WardTimer[MAXWARDS];
new bool:WardSelfInflict[MAXWARDS];
new War3WardAffinity:WardAffinity[MAXWARDS];
new Float:WardInterval[MAXWARDS];

new BeamSprite =-1;
new HaloSprite =-1;

public Plugin:myinfo = 
{
	name = "WCX - Wards",
	author = "Invalid, necavi, PimpinJuice",
	description = "Ward Natives",
	version = "0.1",
	url = "http://necavi.com"
}

public OnPluginStart()
{
	BeamSprite=PrecacheModel("materials/sprites/lgtning.vmt");
	HaloSprite=PrecacheModel("materials/sprites/halo01.vmt");
}

public bool:InitNativesForwards()
{
	CreateNative("War3_CreateWard", Native_War3_CreateWard);
	CreateNative("War3_RemoveWard", Native_War3_RemoveWard);
	return true;
}

public _:Native_War3_CreateWard(Handle:plugin,numParams)
{
	new client = GetNativeCell(1);
	
	for(new i=0;i<MAXWARDS;i++)
	{
		if(WardOwner[i]==0)
		{
			WardOwner[i]=client;
			GetNativeArray(2,WardLocation[i],3);
			WardRadius[i] = GetNativeCell(3);
			WardDuration[i] = Float:GetNativeCell(4);
			WardInterval[i] = Float:GetNativeCell(5);
			WardDamage[i] = GetNativeCell(6);
			WardType[i] = bool:GetNativeCell(7);
			WardSelfInflict[i] = bool:GetNativeCell(8);
			WardAffinity[i] = GetNativeCell(9);
			WardTimer[i] = CreateTimer(WardInterval[i],wardPulse,i,TIMER_REPEAT|TIMER_FLAG_NO_MAPCHANGE);
			if (GetNativeCell(4) > 0) {
				CreateTimer(WardDuration[i],timedRemoveWard,i);
			}
			CurrentWardCount[client]++;
			WardEffect(i);
			return i;
		}
	}
	return -1;
}

public Native_War3_RemoveWard(Handle:plugin,numParams)
{
	return RemoveWard(GetNativeCell(1));
}

public Action:timedRemoveWard(Handle:timer,any:id) {
	RemoveWard(id);
}

public bool:RemoveWard(id)
{
	if (WardOwner[id] == 0)
	{
		return false;
	}
	
	CurrentWardCount[WardOwner[id]]--;
	WardOwner[id] = 0;
	if (WardTimer[id] != INVALID_HANDLE)
	{
		CloseHandle(WardTimer[id]);
	}
	return true;
}


public RemoveWards(client)
{
	for(new i=0;i<MAXWARDS;i++)
	{
		if(WardOwner[i]==client)
		{
			RemoveWard(i);
		}
	}
}

public OnWar3EventSpawn(client)
{	
	for(new i=0;i<MAXWARDS;i++)
	{
		if(WardOwner[i]==client)
		{
			RemoveWard(i);
		}
	}
}

public Action:wardPulse(Handle:timer,any:id) {
	// Conditions can be added here to decide whether or not the pulse will occur.
	// Right now I can't think of any such conditions.
	WardEffect(id);
}

public WardEffect(wardindex) {
	
	new owner = WardOwner[wardindex];
	new beamcolor[4];
	if(WardType[wardindex]==true)
	{
		beamcolor={0,255,0,160};
	} else if(GetClientTeam(owner)==3)
	{
		beamcolor={0,0,255,160};
	} else {
		beamcolor={255,0,0,160};
	}
	
	
	new Float:start_pos[3];
	new Float:end_pos[3];
	new Float:tempVec1[]={0.0,0.0,WARDBELOW};
	new Float:tempVec2[]={0.0,0.0,WARDABOVE};
	AddVectors(WardLocation[wardindex],tempVec1,start_pos);
	AddVectors(WardLocation[wardindex],tempVec2,end_pos);
	TE_SetupBeamPoints(start_pos,end_pos,BeamSprite,HaloSprite,0,GetRandomInt(30,100),WardInterval[wardindex],70.0,70.0,0,30.0,beamcolor,10);
	TE_SendToAll()
	
	new Float:StartRadius = WardRadius[wardindex]/2.0;
	new Speed = RoundToFloor((WardRadius[wardindex]-StartRadius)/WardInterval[wardindex])
	
	TE_SetupBeamRingPoint(WardLocation[wardindex],StartRadius,float(WardRadius[wardindex]),BeamSprite,HaloSprite,0,1,WardInterval[wardindex],20.0,1.5,beamcolor,Speed,0);
	TE_SendToAll();
	new Float:BeamXY[3];
	for(new x=0;x<3;x++) BeamXY[x]=start_pos[x]; //only compare xy
	new Float:BeamZ= BeamXY[2];
	BeamXY[2]=0.0;
	new Float:VictimPos[3];
	new Float:tempZ;
	
	for(new i=1;i<=MaxClients;i++)
	{
		if(ValidPlayer(i,true))
		{
			if (i == WardOwner[wardindex]) {
				if (!WardSelfInflict[wardindex]) {
					continue;
				}
			} else if (GetClientTeam(i) == GetClientTeam(WardOwner[wardindex])) {
				if (WardAffinity[wardindex] == ENEMIES || WardAffinity[wardindex] == SELF_ONLY) {
					continue;
				}
			} else {
				if (WardAffinity[wardindex] == ALLIES || WardAffinity[wardindex] == SELF_ONLY) {
					continue;
				}
			}
			
			GetClientAbsOrigin(i,VictimPos);
			tempZ=VictimPos[2];
			VictimPos[2]=0.0; //no Z
			if(GetVectorDistance(BeamXY,VictimPos) < WardRadius[wardindex]) ////ward RADIUS
			{
				// now compare z
				if(tempZ>BeamZ+WARDBELOW && tempZ < BeamZ+WARDABOVE)
				{
					beamcolor[3]=20;
					if(WardType[wardindex]==true)
					{
						//Heal!!
						new cur_hp=GetClientHealth(i);
						new new_hp=cur_hp+WardDamage[owner];
						new max_hp=War3_GetMaxHP(i);
						if(new_hp>max_hp)	new_hp=max_hp;
						if(cur_hp<new_hp)
						{
							War3_HealToMaxHP(i,WardDamage[wardindex]);
							VictimPos[i]+=65.0;
							War3_TF_ParticleToClient(0, GetClientTeam(i)==2?"healthgained_red":"healthgained_blu", VictimPos);
						}
					} else {
						//Damage! !
						War3_DealDamage(i,WardDamage[wardindex],owner,_,"weapon_wards");
						VictimPos[i]+=65.0;
						War3_TF_ParticleToClient(0, GetClientTeam(i)==2?"healthgained_red":"healthgained_blu", VictimPos);
					}
				}
			}
		}
	}
}



