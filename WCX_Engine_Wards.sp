/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include "W3SIncs/

#define MAXWARDS 64*4 //on map LOL
#define WARDBELOW -2.0 // player is 60 units tall about (6 feet)
#define WARDABOVE 160.0

new bool:WardType[MAXPLAYERSCUSTOM];
new CurrentWardCount[MAXPLAYERSCUSTOM];
new WardStartingArr[]={0,1,2,3,4}; 
new Float:WardLocation[MAXWARDS][3]; 
new WardOwner[MAXWARDS];
new WardRadius[MAXPLAYERSCUSTOM];
new WardDamage[MAXPLAYERSCUSTOM];
new Float:WardDuration[MAXPLAYERSCUSTOM];
new Float:WardExpiration[MAXWARDS];
new Handle:WardTimer[MAXWARDS];
new bool:WardSelfInflict[MAXWARDS];
new bool:WardAffinity[MAXWARDS];

public Plugin:myinfo = 
{
	name = "WCX - Wards",
	author = "necavi, PimpinJuice",
	description = "Ward Natives",
	version = "0.1",
	url = "http://necavi.com"
}

public OnPluginStart()
{
}

public bool:InitNativesForwards()
{
	CreateNative("War3_CreateWard", Native_War3_CreateWard);
	CreateNative("War3_RemoveWard", Native_War3_RemoveWard);
	return true;
}

public _:Native_War3_CreateWard(Handle:plugin,numParams)
{
	new client = GetNativeCell(1);
	
	for(new i=0;i<MAXWARDS;i++)
	{
		if(WardOwner[i]==0)
		{
			WardOwner[i]=client;
			GetNativeArray(2,WardLocation[i]);
			WardRadius[i] = GetNativeCell(3);
			WardDuration[i] = Float:GetNativeCell(4);
			WardInterval[i] = Float:GetNativeCell(5);
			WardDamage[i] = GetNativeCell(6);
			WardType[i] = bool:GetNativeCell(7);
			WardSelfInflict[i] = bool:GetNativeCell(8);
			WardAffinity[i] = War3WardAffinity:GetNativeCell(9);
			WardTimer[i] = CreateTimer(GetNativeCell(5),wardPulse,i,TIMER_REPEAT|TIMER_FLAG_NO_MAPCHANGE);
			if (GetNativeCell(4) > 0) {
				CreateTimer(GetNativeCell(4),timedRemoveWard,i);
			}
			CurrentWardCount[client]++;
			return i;
		}
	}
	return -1;
}

public bool:Native_War3_RemoveWard(Handle:plugin,numParams)
{
	return RemoveWard(GetNativeCell(1));
}

public timedRemoveWard(Handle:timer,any:id) {
	RemoveWard(id);
}

public bool:RemoveWard(id)
{
	if (wardOwner[id] == 0)
	{
		return false;
	}
	
	CurrentWardCount[wardOwner[i]]--;
	WardOwner[i] = 0;
	if (WardTimer[i] != INVALID_HANDLE)
	{
		WardTimer[i].CloseHandle();
	}
	return true;
}


public RemoveWards(client)
{
	for(new i=0;i<MAXWARDS;i++)
	{
		if(WardOwner[i]==client)
		{
			RemoveWard(id);
		}
	}
}

public OnWar3EventSpawn(client)
{	
	for(new i=0;i<MAXWARDS;i++)
	{
		if(WardOwner[i]==client)
		{
			RemoveWard(i);
		}
	}
}

public wardPulse(Handle:timer,any:id) {
	// Conditions can be added here to decide whether or not the pulse will occur.
	// Right now I can't think of any such conditions.
	WardEffect(id);
}

public WardEffect(wardindex) {
	owner = WardOwner[wardindex];
	
	new beamcolor[]={0,255,0,150};
	new Float:start_pos[3];
	new Float:end_pos[3];
	new Float:tempVec1[]={0.0,0.0,WARDBELOW};
	new Float:tempVec2[]={0.0,0.0,WARDABOVE};
	AddVectors(WardLocation[wardindex],tempVec1,start_pos);
	AddVectors(WardLocation[wardindex],tempVec2,end_pos);
	TE_SetupBeamPoints(start_pos,end_pos,BeamSprite,HaloSprite,0,GetRandomInt(30,100),1.2,float(WARDRADIUS),float(WARDRADIUS),0,30.0,beamcolor,10);
	TE_SendToAll();
	new Float:BeamXY[3];
	for(new x=0;x<3;x++) BeamXY[x]=start_pos[x]; //only compare xy
	new Float:BeamZ= BeamXY[2];
	BeamXY[2]=0.0;
	new Float:VictimPos[3];
	new Float:tempZ;
	
	for(new i=1;i<=MaxClients;i++)
	{
		if(ValidPlayer(i,true))
		{
			if (i == WardOwner[wardindex]) {
				if (!WardSelfInflict[wardindex]) {
					continue;
				}
			} else if (GetClientTeam(i) == GetClientTeam(WardOwner[wardindex])) {
				if (WardAffinity[wardindex] == ENEMIES || WardAffinity[wardindex] == SELF_ONLY) {
					continue;
				}
			} else {
				if (WardAffinity[wardindex] == ALLIES || WardAffinity[wardindex] == SELF_ONLY) {
					continue;
				}
			}
			
			GetClientAbsOrigin(i,VictimPos);
			tempZ=VictimPos[2];
			VictimPos[2]=0.0; //no Z
			if(GetVectorDistance(BeamXY,VictimPos) < WARDRADIUS) ////ward RADIUS
			{
				// now compare z
				if(tempZ>BeamZ+WARDBELOW && tempZ < BeamZ+WARDABOVE)
				{
					//Heal!!
					new DamageScreen[4];
					DamageScreen[0]=beamcolor[0];
					DamageScreen[1]=beamcolor[1];
					DamageScreen[2]=beamcolor[2];
					DamageScreen[3]=20; //alpha
					new cur_hp=GetClientHealth(i);
					new new_hp=cur_hp+WARDHEAL;
					new max_hp=War3_GetMaxHP(i);
					if(new_hp>max_hp)	new_hp=max_hp;
					if(cur_hp<new_hp)
					{
						if(!flashedscreen[i]){
							flashedscreen[i]=true;
							W3FlashScreen(i,DamageScreen);
						}
						//SetEntityZHealth(i,new_hp);
						War3_HealToMaxHP(i,WARDHEAL);
						VictimPos[i]+=65.0;
						War3_TF_ParticleToClient(0, GetClientTeam(i)==2?"healthgained_red":"healthgained_blu", VictimPos);
					}
				}
			}
		}
	}
}